/*****************************************************************************/
/* Fish Feeder - Project by Carlos Filipe ZeeTeck                            */
/* Version: 1.5                                                              */
/* Last Update: 09/05/2025                                                   */
/* Hardware: Arduino Uno R3                                                  */
/*****************************************************************************/

// ğŸ“š Libraries
#include <Wire.h>             // Library for I2C communication (used by RTC and Display)
#include <U8g2lib.h>          // Library to control the OLED display (U8G2 library)
#include "Ds1302.h"           // Library to manage the DS1302 Real Time Clock (RTC) module

// ğŸ”§ Pin Configuration (define all connections between Arduino and components)
const uint8_t HALL_PIN    = 2;    // Hall effect sensor input pin (counts motor rotations)

const uint8_t DAT_PIN     = 3;     // RTC - Data pin
const uint8_t CLK_PIN     = 4;     // RTC - Clock pin
const uint8_t RST_PIN     = 5;     // RTC - Reset pin

const uint8_t LED_RED     = 6;     // Red LED to indicate system error
const uint8_t LED_GREEN   = 7;     // Green LED to indicate system OK

const uint8_t BTN_ENTER   = 8;     // Button to confirm actions (ENTER)
const uint8_t BTN_PLUS    = 9;     // Button to increase values or navigate (PLUS)
const uint8_t BTN_MINUS   = 10;    // Button to decrease values or navigate (MINUS)

const uint8_t MOTOR_ON    = 11;     // Motor Relay control pin (also used to light a yellow LED)

const uint8_t BTN_BACK    = 12;    // Button to go back or cancel actions (BACK)

// ğŸ¯ Screen Identifiers (used to control which screen to display on the OLED)
const uint8_t SCREEN_LOGO    = 1;  // Startup Logo screen
const uint8_t SCREEN_HOUR    = 2;  // Clock screen showing current time
const uint8_t SCREEN_ERROR   = 3;  // Error screen showing system faults
const uint8_t SCREEN_MANUAL  = 4;  // Manual feeding mode screen
const uint8_t SCREEN_FEEDING = 5;  // Automatic feeding in progress screen

// âš ï¸ Error Identifiers (used to define and track system errors)
const uint8_t NO_ERROR    = 0;     // No error detected
const uint8_t RTC_ERROR   = 1;     // Real Time Clock communication error
const uint8_t MOTOR_ERROR = 2;     // Motor or sensor malfunction error

// ğŸ“¦ Objects (create instances to control hardware modules)
Ds1302 rtc(RST_PIN, CLK_PIN, DAT_PIN);                            // Instance to manage RTC functions
U8G2_SH1106_128X64_NONAME_F_HW_I2C display(U8G2_R0, U8X8_PIN_NONE); // Instance to manage OLED display functions

// ğŸ•’ RTC Current Date and Time Storage
Ds1302::DateTime now;                     // Variable to store the current date and time read from RTC

// ğŸ–¥ï¸ Screen Management Variables
uint8_t screenNumber = SCREEN_LOGO;       // Tracks which screen should be displayed (starts with the logo)
unsigned long lastScreenChange = 0;       // Tracks the last time the screen changed (for screensaver timing)
bool showLogo = false;                    // Flag to alternate between logo and clock screens (screensaver logic)

// âš™ï¸ Motor and Pulse Counting Control
const unsigned int PULSES_PER_TURN = 4051; // Number of pulses needed for a full rotation (calibrated value)

unsigned int pulseTarget = 0;             // Target number of pulses needed (calculated based on doses)
volatile unsigned int pulseCount = 0;     // Counter to track pulses from the Hall sensor (updated via interrupt)

bool motorActive = false;                 // Flag indicating whether the motor is currently running
bool manualActive = false;                // Flag indicating whether manual feeding is active
unsigned long manualStartTime = 0;        // Timestamp when manual feeding started
unsigned long manualPressTime = 0;        // Timestamp when manual button press started
bool manualRequest = false;               // Flag indicating a manual feeding request is pending

// âš ï¸ Error Handling Variables
unsigned int lastPulseSnapshot = 0;       // Snapshot of the pulse count used to detect motor stall
uint8_t errorType = NO_ERROR;             // Stores the current error type (no error by default)

// ğŸŸ Feeding Schedule Definition
// Each row defines: [hour, minute, doses, active (1/0), alreadyFed (1/0)]
uint8_t setPoint[3][5] = {
  {8, 13, 1, 1, 0},                      // Feed at 08:13, 1 dose, active, not yet fed today
  {8, 14, 2, 1, 0},                      // Feed at 08:14, 2 dose, active, not yet fed today
  {8, 15, 1, 0, 0}                       // Feed at 08:15, 1 dose, inactive, not yet fed today
};


// ğŸ–¼ï¸ Display Bitmaps (Images displayed on the OLED screen)

// This bitmap represents the startup logo or brand image.
// The array contains pixel data in monochrome format (1-bit per pixel).
// Use a bitmap converter like "image2cpp" to generate this kind of array.
const unsigned char myLogoBitmap[] PROGMEM = { 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x0f, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x7f, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x3f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x1f, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0x00, 0x07, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x07, 0x00, 0x80, 0x1f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x07, 0x00, 0xc0, 0x3f, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x03, 0x00, 0xe0, 0x39, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x01, 0x80, 0xff, 0x78, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x01, 0xc0, 0xff, 0x78, 0xe0, 0x3f, 0xe0, 0xff, 0xff, 0x0f, 0xe0, 0xff, 0xff, 0xef, 0xff, 
  0xff, 0x00, 0xe0, 0xff, 0x39, 0xe0, 0x1f, 0xc0, 0xff, 0xff, 0x0f, 0xc0, 0xff, 0xff, 0xcf, 0xff, 
  0xff, 0x00, 0xf0, 0xc0, 0x3f, 0xc0, 0x1f, 0xc0, 0xff, 0xff, 0x0f, 0xc0, 0xff, 0xff, 0xcf, 0xff, 
  0xff, 0x00, 0x78, 0x80, 0x1f, 0xc0, 0xff, 0xc1, 0xff, 0xff, 0x7f, 0xf8, 0xff, 0xff, 0xcf, 0xff, 
  0xff, 0xff, 0x3f, 0x00, 0x0f, 0xc0, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xcf, 0xff, 
  0xff, 0xff, 0x1f, 0x00, 0x00, 0xc0, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xcf, 0xff, 
  0xff, 0xff, 0x07, 0x00, 0x00, 0x80, 0xff, 0xf1, 0x81, 0x0f, 0xfc, 0xf8, 0xe0, 0x07, 0xcf, 0xe3, 
  0xff, 0x00, 0x00, 0x1e, 0x00, 0x80, 0xff, 0xf1, 0x00, 0x07, 0xf8, 0x78, 0xc0, 0x03, 0xce, 0xf1, 
  0x7f, 0x00, 0x00, 0x3f, 0x00, 0x80, 0xff, 0xf0, 0x18, 0x87, 0xf8, 0x38, 0x84, 0x21, 0x8c, 0xf8, 
  0x7f, 0x00, 0x80, 0x7f, 0x00, 0x80, 0xff, 0x78, 0x3c, 0xe2, 0xf1, 0x3c, 0x8e, 0x71, 0x00, 0xf8, 
  0xff, 0xff, 0xff, 0x73, 0x00, 0x80, 0x7f, 0x78, 0x3c, 0xe0, 0xf1, 0x3c, 0x8e, 0xf0, 0x06, 0xfc, 
  0xff, 0xff, 0xff, 0x73, 0x00, 0x80, 0x7f, 0x7c, 0x18, 0xc0, 0xf0, 0x3c, 0x84, 0xf8, 0x0f, 0xfe, 
  0xff, 0xff, 0xff, 0x77, 0x00, 0x80, 0x3f, 0x7e, 0x00, 0x00, 0xf0, 0x3c, 0x80, 0xf8, 0x0f, 0xfe, 
  0x7f, 0x00, 0x80, 0x3f, 0x00, 0xc0, 0x3f, 0x7e, 0x80, 0x03, 0xfc, 0x3c, 0xe0, 0xf9, 0x0f, 0xfc, 
  0x7f, 0x00, 0x00, 0x1f, 0x00, 0xc0, 0x1f, 0x7f, 0xfc, 0xe3, 0xff, 0x3c, 0xfe, 0xf1, 0x0f, 0xf8, 
  0xff, 0x00, 0x00, 0x0c, 0x00, 0xc0, 0x1f, 0x7f, 0xfc, 0xe3, 0xff, 0x3c, 0xfe, 0xf1, 0x87, 0xf8, 
  0xff, 0x01, 0x00, 0x00, 0x00, 0xc0, 0x0f, 0x7e, 0x18, 0xc7, 0xf9, 0x38, 0x8e, 0x71, 0xc4, 0xf1, 
  0xff, 0xff, 0x0f, 0x00, 0x00, 0xe0, 0x0f, 0xc0, 0x00, 0x07, 0xf8, 0x38, 0xc0, 0x01, 0xcc, 0xf1, 
  0xff, 0xff, 0x3f, 0x80, 0x07, 0xe0, 0x0f, 0xc0, 0x81, 0x0f, 0xfc, 0x7c, 0xc0, 0x03, 0xce, 0xe3, 
  0xff, 0x03, 0x78, 0xc0, 0x0f, 0xf0, 0xff, 0xff, 0xe7, 0x3f, 0xff, 0xff, 0xf1, 0x8f, 0xff, 0xff, 
  0xff, 0x03, 0xf0, 0xf1, 0x0f, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x07, 0xe0, 0xff, 0x1c, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x07, 0xc0, 0xff, 0x0e, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x0f, 0x00, 0xe0, 0x0f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x1f, 0x00, 0x80, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0x3f, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x01, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x07, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x3f, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char manualBitmap[] PROGMEM = { 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x3f, 0x80, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x0f, 0x00, 0xfe, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x07, 0x0e, 0xfc, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x7f, 0xf8, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xf0, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xf1, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xe3, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x7f, 0xfc, 0xff, 0xe7, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xfc, 0xff, 0xc7, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfe, 0xff, 0xc7, 0xff, 0xff, 
  0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfe, 0xff, 0xcf, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfe, 0xff, 0xcf, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfe, 0xff, 0xc7, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfe, 0xff, 0xc7, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xfc, 0xff, 0xc7, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xfc, 0xff, 0xe3, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xf8, 0xbf, 0xe3, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xf8, 0x3f, 0xf1, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xf1, 0x1f, 0xf0, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xc3, 0x1f, 0xf8, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x87, 0x1f, 0xfc, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0x8f, 0x0f, 0xf8, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0x0f, 0xf8, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
const unsigned char FeedingBitmap [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0x3f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0xff, 0xfc, 0x01, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0x00, 0xfc, 0xe7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x7c, 0x3e, 0x00, 0xf0, 0xe3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x3f, 0x3f, 0x00, 0xf8, 0x1f, 0x00, 0xe0, 0xf1, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7f, 0x1e, 0x00, 0xf0, 0x9f, 0x01, 0xc0, 0xf0, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x00, 0xe3, 0x8f, 0x01, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xe3, 0x07, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x00, 0xe0, 0x03, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7f, 0x1c, 0x00, 0xf0, 0x07, 0x00, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x3f, 0x1e, 0x00, 0xf8, 0x0f, 0x00, 0xc0, 0xf0, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xfc, 0x1f, 0x00, 0xe0, 0xf0, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0x3f, 0x00, 0xf0, 0xe1, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0x7f, 0x00, 0xfc, 0xe3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xfe, 0xc7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc7, 0x9f, 0x1f, 0x7f, 0xfe, 0xfc, 0xf1, 0xe3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xb1, 0x27, 0x4e, 0x1c, 0x3d, 0x71, 0xe4, 0x89, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x3c, 0xf8, 0xe0, 0xc1, 0x83, 0x07, 0x0f, 0x3c, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7e, 0xfc, 0xf1, 0xe3, 0xc7, 0x8f, 0x3f, 0x7e, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff
};

// ğŸ“¢ Function Declarations (List of all function headers used in the program)
// These declarations make the functions recognizable before they are defined below.
void updateScreen();                           // Handles screen content based on the current state
void showScreenHour();                         // Displays the current time on the screen
void showErrorScreen();                        // Displays error messages based on system state
void checkRTC();                               // Reads and validates the RTC module data
void showImageBitmap(const uint8_t *bitmap);   // Displays a bitmap image on the screen
void screenSaver();                            // Manages screen saver transitions (logo/hour display)
void checkFeedingTime();                       // Verifies if it's time for an automatic feeding
void resetFeedingFlags();                      // Resets daily feeding status at midnight
void checkManualMode();                        // Detects manual feeding button combination
void countPulse();                             // Interrupt service routine to count pulses from the Hall sensor
void checkMotorError();                        // Verifies if the motor is running correctly
void checkRotationDone();                      // Checks if the motor has reached the target number of pulses for a full rotation



// ğŸ›  Setup Function (Runs once when the Arduino starts)
void setup() {
  rtc.init();                                    // Initialize the RTC module (Real-Time Clock)
  display.begin();                               // Initialize the OLED display

  // Configure output pins for LEDs and motor control
  pinMode(LED_GREEN, OUTPUT);                    // Set Green LED pin as OUTPUT (indicates system OK)
  pinMode(LED_RED, OUTPUT);                      // Set Red LED pin as OUTPUT (indicates error)
  pinMode(MOTOR_ON, OUTPUT);                     // Set Motor control pin (relay + yellow LED) as OUTPUT

  // Ensure all outputs start OFF
  digitalWrite(LED_GREEN, HIGH);                 // Turn On Green LED
  digitalWrite(LED_RED, LOW);                    // Turn off Red LED
  digitalWrite(MOTOR_ON, LOW);                   // Turn off Motor (relay and yellow LED)

  // Configure input pins for user buttons with internal pull-up resistors
  pinMode(BTN_ENTER, INPUT_PULLUP);              // Enter button (user menu interaction)
  pinMode(BTN_PLUS, INPUT_PULLUP);               // Plus button (navigation or dosing)
  pinMode(BTN_MINUS, INPUT_PULLUP);              // Minus button (navigation or dosing)
  pinMode(BTN_BACK, INPUT_PULLUP);               // Back button (return to previous screen)

  // Configure Hall effect sensor input (no pull-up as it's external hardware controlled)
  pinMode(HALL_PIN, INPUT_PULLUP);                      // Hall sensor for detecting rotations (motor feedback)

  // Attach an interrupt to the Hall sensor
  // Every time the sensor detects a rising edge (LOW to HIGH transition), 
  // it calls the countPulse() function to increment the pulse counter.
  attachInterrupt(digitalPinToInterrupt(HALL_PIN), countPulse, RISING);

  // Short delay to allow components to stabilize on power-up
  delay(100);                                   // Wait 100ms after initialization
}


// ğŸ”„ Main Loop (Runs continuously after setup)
//
// This is the continuous execution cycle responsible for:
// - Checking system health (RTC and Motor)
// - Managing feeding schedules (automatic and manual)
// - Handling screen updates
// - Ensuring safe motor operation, even in degraded system states

void loop() {
  checkRTC();  // ğŸ§  Always check and update the RTC status to ensure the clock is running correctly.

  // ğŸš§ If the motor is healthy (no MOTOR_ERROR), allow the user to trigger manual feeding.
  // This allows manual operation even if the RTC fails.
  if (errorType != MOTOR_ERROR) {
    checkManualMode();  // âœ‹ Listen for manual feeding button press.
  }

  // âœ… Proceed with scheduled operations and screensaver only if no critical error screen is active.
  if (screenNumber != SCREEN_ERROR) {
    screenSaver();        // ğŸ–¥ï¸ Handle logo and clock screen transitions (screensaver).
    checkFeedingTime();   // ğŸ½ï¸ Check if itâ€™s time to trigger a scheduled automatic feeding.
    resetFeedingFlags();  // â™»ï¸ Reset daily feeding status at midnight.
  }

  // ğŸ› ï¸ Always monitor motor behavior while it's running, even if the RTC has failed or an error screen is showing.
  // This ensures safe stopping or completion of motor actions.
  if (motorActive) {
    checkMotorError();     // âš ï¸ Monitor motor pulses to detect jams or failures.
    checkRotationDone();   // ğŸ”„ Verify if the motor has completed the required rotation (pulse target reached).
  }

  updateScreen();  // ğŸ“º Always refresh the display to reflect the latest system status.
}




// ğŸ“º Update Screen
// This function updates the OLED display based on the current screen state.
// It is called continuously to ensure the user always sees the latest system status.
void updateScreen() {
  switch (screenNumber) {

    case SCREEN_LOGO:
      showImageBitmap(myLogoBitmap);         // Show the logo image (used during idle/screen saver mode).
      break;

    case SCREEN_HOUR:
      showScreenHour();                      // Display the current hour and minute in large format.
      break;

    case SCREEN_ERROR:
      showErrorScreen(errorType);            // Display an error message (RTC or motor failure).
      break;

    case SCREEN_MANUAL:
      showImageBitmap(manualBitmap);         // Display an image indicating that manual feeding is active.
      break;

    case SCREEN_FEEDING:
      showImageBitmap(FeedingBitmap);        // Display an image showing that automatic feeding is in progress.
      break;

    default:
      showImageBitmap(myLogoBitmap);         // Fallback to the logo if the screen number is unknown.
      break;
  }
}

// âŒš Display Current Time Screen
// This function draws the current hour and minute on the OLED display in a large, centered font.
// It runs continuously when the system is in CLOCK SCREEN mode.
void showScreenHour() {
  
  char timeStr[6];  // Prepare a 6-character array to hold the formatted time string in "HH:MM" format.
                    // Example: "07:02" requires 5 characters + 1 null terminator '\0'.

  sprintf(timeStr, "%02d:%02d", now.hour, now.minute);  // Format hours and minutes as two digits each, separated by ":".

  display.clearBuffer();  // Clear the display's internal memory to prepare for new content.

  display.setFont(u8g2_font_fub30_tr);  // Set a large and readable font for the time display.
                                       // Font details can be found in the U8g2 library documentation.

  uint8_t strWidth = display.getStrWidth(timeStr);  // Calculate the width of the formatted string in pixels.
  uint8_t x = (128 - strWidth) / 2;                 // Center the string horizontally on a 128-pixel-wide screen.

  display.drawStr(x, 46, timeStr);  // Draw the formatted time at the calculated horizontal position (x) and vertical position (y = 46).

  display.sendBuffer();  // Send all drawing commands to the display hardware to update the screen.
}


// âŒ Display Error Screen
// This function shows an error message on the OLED display based on the received error code.
// It helps the user quickly identify system problems like RTC failure or motor malfunction.
void showErrorScreen(uint8_t errorNumber) {

  switch (errorNumber) {

    case RTC_ERROR:
      display.clearBuffer();                                // Clear the display's internal memory.
      display.setFont(u8g2_font_ncenB14_tr);                 // Set a smaller font suitable for error messages.
      display.drawStr(15, 28, "ERROR 01");                   // Display error code "ERROR 01" at position (15, 28).
      display.drawStr(17, 48, "RTC NOK");                    // Display "RTC NOK" indicating RTC (clock) failure.
      display.sendBuffer();                                 // Update the display with the error message.
      break;

    case MOTOR_ERROR:
      display.clearBuffer();                                // Clear the display's internal memory.
      display.setFont(u8g2_font_ncenB14_tr);                 // Set the font for the error message.
      display.drawStr(15, 28, "ERROR 02");                   // Display error code "ERROR 02" at position (15, 28).
      display.drawStr(16, 48, "Motor NOK");                  // Display "Motor NOK" indicating motor or sensor failure.
      display.sendBuffer();                                 // Update the display with the error message.
      break;

    case NO_ERROR:
      display.clearBuffer();                                // Clear the display's internal memory.
      display.setFont(u8g2_font_ncenB14_tr);                 // Set the font for the system status message.
      display.drawStr(15, 28, "System");                     // Display "System" indicating system status.
      display.drawStr(17, 48, "OK");                         // Display "OK" indicating normal operation.
      display.sendBuffer();                                 // Update the display with the status message.
      break;

    default:                                                // For any unknown error code, treat as NO_ERROR.
      display.clearBuffer();                                
      display.setFont(u8g2_font_ncenB14_tr);                
      display.drawStr(15, 28, "System");                     
      display.drawStr(25, 48, "OK");                         
      display.sendBuffer();                                 
      break;
  }
}


// ğŸ§  Check RTC Health
// This function verifies if the RTC (Real-Time Clock) is updating correctly.
// It checks once per second if the 'seconds' value has changed.
// If the RTC stops updating, it triggers an RTC error and shows the error screen.
// If the RTC recovers, it clears the RTC error *only if the motor is not in error*.
void checkRTC() {
  static unsigned long lastCheck = 0;   // Timestamp of the last RTC check.
  static uint8_t lastSecond = 255;      // Stores the last detected second (initialized to force first read).

  if (millis() - lastCheck >= 1000) {   // Perform the check every 1000 ms (1 second).
    lastCheck = millis();               // Update the check timestamp.
    rtc.getDateTime(&now);              // Read the current date and time from the RTC.

    if (now.second != lastSecond) {     // RTC is updating (second has changed).
      lastSecond = now.second;          // Store the new second value.

      // ğŸŸ¢ If the motor had no error, clear RTC error and return to normal.
      if (errorType == MOTOR_ERROR) {
        // Do nothing, keep the MOTOR_ERROR active as priority.
        errorType = MOTOR_ERROR;
      } else {
        errorType = NO_ERROR;           // Clear RTC error.
      }

      // âœ… If the error screen is being shown and the system is back to normal, restore the logo screen.
      if (screenNumber == SCREEN_ERROR && errorType == NO_ERROR) {
        screenNumber = SCREEN_LOGO;     // Go back to the logo screen.
        digitalWrite(LED_GREEN, HIGH);  // Turn ON the Green LED (system OK).
        digitalWrite(LED_RED, LOW);     // Turn OFF the Red LED (no error).
      }

    } else {                            // RTC did not update (stuck or not communicating).
      digitalWrite(LED_GREEN, LOW);     // Turn OFF the Green LED (not OK).
      digitalWrite(LED_RED, HIGH);      // Turn ON the Red LED (error).
      screenNumber = SCREEN_ERROR;      // Display the error screen.
      errorType = RTC_ERROR;            // Mark the error as RTC failure.
    }
  }
}




// ğŸ–¼ï¸ Display Bitmap on Screen
// This function receives a bitmap and renders it on the OLED screen.
void showImageBitmap(const uint8_t *bitmap) {
  display.clearBuffer();                            // Clear the display's internal buffer.
  display.drawXBMP(0, 0, 128, 64, bitmap);          // Draw the bitmap at position (0,0) on a 128x64 display.
  display.sendBuffer();                            // Push the image to the OLED display.
}


// ğŸ” Screensaver Manager
// Toggles between the Logo and Hour display every 10 seconds.
// Active only when the current screen is either the Logo or the Hour.
void screenSaver() {
  if (screenNumber == SCREEN_LOGO || screenNumber == SCREEN_HOUR) {  // Only toggle if in Logo or Hour mode.
    if (millis() - lastScreenChange >= 10000) {                      // If 10 seconds have passed since the last change.
      showLogo = !showLogo;                                          // Toggle the flag (switch between Logo and Hour).
      lastScreenChange = millis();                                   // Update the last change timestamp.
    }

    // Update screen based on the toggled flag, only if the screen is not already showing the desired content.
    if (showLogo && screenNumber != SCREEN_LOGO) {
      screenNumber = SCREEN_LOGO;
    } else if (!showLogo && screenNumber != SCREEN_HOUR) {
      screenNumber = SCREEN_HOUR;
    }
  }
}

// ğŸ½ï¸ Scheduled Feeding Handler
// This function checks if it is time to feed the fish based on predefined set points.
// If the time matches and feeding hasn't been done yet, the motor is activated.
void checkFeedingTime() {
  if (motorActive) return;  // If the motor is already running, exit this function to avoid interference.

  for (uint8_t i = 0; i < 3; i++) {  // Loop through the three defined feeding schedules (set points).
    // Check if the current hour and minute match a set point,
    // the set point is active, and the feeding has not been done today.
    if (now.hour == setPoint[i][0] && 
        now.minute == setPoint[i][1] &&
        setPoint[i][3] == 1 && 
        setPoint[i][4] == 0) {

      pulseTarget = setPoint[i][2] * PULSES_PER_TURN;  // Calculate the total number of pulses based on the desired dose.
      pulseCount = 0;                                 // Reset the pulse counter.
      motorActive = true;                             // Mark the motor as active.
      digitalWrite(MOTOR_ON, HIGH);                   // Turn ON the motor (activates relay and yellow LED).
      screenNumber = SCREEN_FEEDING;                  // Change screen to show feeding status.
      setPoint[i][4] = 1;                             // Mark this feeding as done for today to avoid repetition.
      break;                                         // Exit the loop after finding a valid feeding schedule.
    }
  }
}


// â™»ï¸ Daily Feeding Reset
// This function resets the 'already fed' flags every new day.
// Ensures the system can feed again on the next day.
void resetFeedingFlags() {
  static uint8_t lastDay = 0;  // Keeps track of the last processed day.

  if (now.day != lastDay) {    // If the day has changed since the last check...
    for (uint8_t i = 0; i < 3; i++) {  // Loop through all set points.
      setPoint[i][4] = 0;              // Reset the 'already fed' flag for each set point.
    }
    lastDay = now.day;  // Update the last processed day.
  }
}


// âœ‹ Manual Feeding Handler
// This function allows the user to trigger a manual feeding cycle by pressing both buttons (+ and -) simultaneously 
// and holding them for 3 seconds. This is designed to avoid accidental activation.
//
// âœ… Conditions to trigger manual feeding:
// - Motor must NOT be already running.
// - Both buttons (+ and -) must be pressed at the same time for 3 seconds.
// - User must release both buttons after confirmation to start the motor.
//
// ğŸ›¡ï¸ Safety Features:
// - Debouncing and timing to avoid accidental activation.
// - Resets request if buttons are released too early.
// - Only starts the motor when safe conditions are met.
void checkManualMode() {
  if (digitalRead(MOTOR_ON) == HIGH) return;  // ğŸ›‘ Exit if motor is already active.

  // ğŸ•’ Detect simultaneous press of PLUS and MINUS buttons to start manual request timer
  if (digitalRead(BTN_PLUS) == HIGH && digitalRead(BTN_MINUS) == HIGH && !manualRequest) {
    if (manualPressTime == 0)
      manualPressTime = millis();  // Start timing when buttons are first detected as pressed.

    // âœ… Confirm manual request if held for 3 seconds
    if (!manualActive && (millis() - manualPressTime >= 3000)) {
      manualRequest = true;  // Mark that user has requested manual feeding.
    }
  } else {
    manualPressTime = 0;  // ğŸ”„ Reset timer if buttons are released too early.
  }

  // ğŸš€ Start feeding when user releases both buttons after confirmation
  if (digitalRead(BTN_PLUS) == LOW && digitalRead(BTN_MINUS) == LOW && manualRequest && digitalRead(MOTOR_ON) == LOW) {
    manualActive = true;                     // Flag manual mode as active.
    pulseCount = 0;                          // Reset pulse counter.
    motorActive = true;                      // Flag motor as active.
    screenNumber = SCREEN_MANUAL;            // Switch to manual feeding display.
    pulseTarget = PULSES_PER_TURN;           // Set target pulses for one full rotation.
    digitalWrite(MOTOR_ON, HIGH);            // Start motor and yellow LED.
  }
}

// ğŸ“ˆ Pulse Counting Handler
// This interrupt function is triggered on every rising edge detected by the Hall sensor.
// It simply increments the pulse counter to track motor rotation.
// âš ï¸ Keep this function short and efficient to avoid timing issues.
void countPulse() {
  pulseCount++;
}

// ğŸ”„ Rotation Completion Check
// This function verifies if the motor has completed the required rotation by checking the pulse count.
// When the target pulse count is reached, it stops the motor and resets related states.
void checkRotationDone() {
  if (pulseCount >= pulseTarget) {       // âœ… Stop when the target number of pulses is reached.
    digitalWrite(MOTOR_ON, LOW);         // ğŸ›‘ Stop the motor (and the yellow LED).
    manualActive = false;                // ğŸ”„ Reset manual feeding flag.
    motorActive = false;                 // ğŸ”„ Reset automatic feeding flag.
    manualRequest = false;               // ğŸ”„ Clear manual feeding request.
    pulseCount = 0;                      // ğŸ”„ Reset the pulse counter for the next operation.
    screenNumber = SCREEN_LOGO;          // ğŸ–¥ï¸ Return to the logo screen.
    manualPressTime = 0;                 // ğŸ”„ Reset manual button press tracking.
  }
}

// âš ï¸ Motor Error Monitoring (Stall Detection)
// This function monitors the motor while running to ensure pulses are being received.
// If no new pulses are detected for more than 2 seconds, it assumes a stall or malfunction and stops the motor.
void checkMotorError() {
  static unsigned long motorErrorTimerStart = 0;  // Records when the motor started for timing the error check.

  if (digitalRead(MOTOR_ON) == HIGH) {  // ğŸŸ¢ Motor is running.
    if (motorErrorTimerStart == 0) {
      motorErrorTimerStart = millis();       // ğŸ•’ Start timing when motor starts.
      lastPulseSnapshot = pulseCount;        // ğŸ“Š Record the current pulse count as reference.
    }

    // ğŸŸ¢ Reset timer if new pulses are detected (motor is rotating correctly).
    if (pulseCount != lastPulseSnapshot) {
      motorErrorTimerStart = millis();       // ğŸ•’ Reset the timer.
      lastPulseSnapshot = pulseCount;        // ğŸ“Š Update pulse snapshot.
    }

    // âš ï¸ If no pulses are detected for more than 2 seconds, trigger error.
    if (millis() - motorErrorTimerStart > 2000) {
      errorType = MOTOR_ERROR;               // ğŸš¨ Set motor error state.
      digitalWrite(MOTOR_ON, LOW);           // ğŸ›‘ Stop the motor.
      screenNumber = SCREEN_ERROR;           // ğŸ“º Show error screen.
      digitalWrite(LED_GREEN, LOW);          // ğŸ”´ Turn off green LED.
      digitalWrite(LED_RED, HIGH);           // ğŸ”´ Turn on red LED.
      motorActive = false;                   // ğŸ”„ Clear motor active flag.
      manualRequest = false;                 // ğŸ”„ Clear manual request flag.
      manualActive = false;                  // ğŸ”„ Clear manual active flag.
    }

  } else if (digitalRead(MOTOR_ON) == LOW && errorType == NO_ERROR) {
    // ğŸ”„ Reset timer and LEDs if motor is off and no error is present.
    motorErrorTimerStart = 0;
    errorType = NO_ERROR;
    screenNumber = SCREEN_LOGO;              // ğŸ–¥ï¸ Return to logo screen.
    digitalWrite(LED_GREEN, HIGH);           // ğŸŸ¢ Green LED ON (system OK).
    digitalWrite(LED_RED, LOW);              // ğŸ”´ Red LED OFF.
  }
}
